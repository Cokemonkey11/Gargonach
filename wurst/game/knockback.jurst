
library knockback requires IsTerrainWalkable, units, helper
    class knockDat
        unit u
        real xOffs
        real yOffs
        real zOffs
    end

    globals
        private constant int CROWID = 'Arav'
        private constant real BOUNCECOEFFICIENT = .4
        private constant real FRICTION = .15
        private constant real GRAVITY = 1.375
        private constant real MAXZVELOCITYTOBOUNCE = -10.
        private constant real MINFLYHEIGHT = 5.
        private constant real MINFORKNOCKBACK = 1.
        private constant real MINFRICTIONFOREFFECTSQUARED = 9.
        private constant real MINZVELOCITYTOBECOMEAIRBORNE = 5.
        private constant string FRICTIONMODEL = "Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl"
        private constant string STUNORDERSTRING = "thunderbolt"
        private effect fx
        private int dbIndex = -1
        private knockDat array knockDB
        private timer time = CreateTimer()
    end

    private function p()
        int index = 0
        real flyHeight
        real unitX
        real unitY
        real heightDifference
        real newX
        real newY
        real vel2d
        knockDat tempDat
        loop
            exitwhen index > dbIndex
            tempDat = knockDB[index]
            unitX = GetUnitX(tempDat.u)
            unitY = GetUnitY(tempDat.u)
            newX = unitX + tempDat.xOffs
            newY = unitY + tempDat.yOffs
            flyHeight = GetUnitFlyHeight(tempDat.u)
            vel2d = (tempDat.xOffs*tempDat.xOffs + tempDat.yOffs*tempDat.yOffs)
            if flyHeight < MINFLYHEIGHT
                if IsTerrainWalkable(newX, newY)
                    SetUnitX(tempDat.u, unitX + tempDat.xOffs)
                    SetUnitY(tempDat.u, unitY + tempDat.yOffs)
                    tempDat.xOffs = tempDat.xOffs*(1-FRICTION)
                    tempDat.yOffs = tempDat.yOffs*(1-FRICTION)
                    SetUnitMoveSpeed(tempDat.u, GetUnitDefaultMoveSpeed(tempDat.u))
                    if tempDat.xOffs*tempDat.yOffs > MINFRICTIONFOREFFECTSQUARED
                        fx = AddSpecialEffect(FRICTIONMODEL, unitX, unitY)
                        DestroyEffect(fx)
                    end
                else
                    tempDat.xOffs = 0
                    tempDat.yOffs = 0
                    /*
                    if vel2d > MINFORSTUN
                        UnitAddAbility(units_globalDummy, STUNID)
                        IssueTargetOrder(units_globalDummy, STUNORDERSTRING, tempDat.u)
                        UnitRemoveAbility(units_globalDummy, STUNID)
                    end
                    */
                end
                if tempDat.zOffs < MAXZVELOCITYTOBOUNCE
                    tempDat.zOffs = tempDat.zOffs*-1.*BOUNCECOEFFICIENT
                end
                if tempDat.zOffs > MINZVELOCITYTOBECOMEAIRBORNE
                    SetUnitFlyHeight(tempDat.u, flyHeight + tempDat.zOffs, 0)
                    tempDat.zOffs = tempDat.zOffs-GRAVITY
                end
            else
                tempDat.zOffs = tempDat.zOffs-GRAVITY
                heightDifference = helper_getZ(newX, newY)-helper_getZ(unitX, unitY)
                SetUnitFlyHeight(tempDat.u, flyHeight + tempDat.zOffs-heightDifference, 0)
                SetUnitX(tempDat.u, newX)
                SetUnitY(tempDat.u, newY)
                SetUnitMoveSpeed(tempDat.u, 0)
            end
            if vel2d < MINFORKNOCKBACK and tempDat.zOffs > MAXZVELOCITYTOBOUNCE and tempDat.zOffs < -1*MAXZVELOCITYTOBOUNCE and flyHeight < MINFLYHEIGHT
                knockDB[index] = knockDB[dbIndex]
                dbIndex--
                SetUnitFlyHeight(tempDat.u, 0, 0)
                SetUnitMoveSpeed(tempDat.u, GetUnitDefaultMoveSpeed(tempDat.u))
                destroy tempDat
                if dbIndex < 0
                    PauseTimer(time)
                end
            end
            index++
        end
    end

    private function getUnitIndexFromStack takes unit u returns int
        int index = 0
        int returner = -1
        knockDat tempDat
        loop
            exitwhen index > dbIndex or returner != -1
            tempDat = knockDB[index]
            if tempDat.u == u
                returner = index
            end
            index++
        end
        return returner
    end

    public function add takes unit u, real power, real direction, real trajectory returns nothing
        int index = getUnitIndexFromStack(u)
        knockDat tempDat
        if index == -1
            tempDat = new knockDat
            tempDat.u = u
            tempDat.xOffs = power*Cos(direction)*Cos(trajectory)
            tempDat.yOffs = power*Sin(direction)*Cos(trajectory)
            tempDat.zOffs = power*Sin(trajectory)
            dbIndex++
            knockDB[dbIndex] = tempDat
            UnitAddAbility(tempDat.u, CROWID)
            UnitRemoveAbility(tempDat.u, CROWID)
            if dbIndex == 0
                TimerStart(time, .03, true, function p)
            end
        else
            tempDat = knockDB[index]
            tempDat.xOffs = tempDat.xOffs + power*Cos(direction)*Cos(trajectory)
            tempDat.yOffs = tempDat.yOffs + power*Sin(direction)*Cos(trajectory)
            tempDat.zOffs = tempDat.zOffs + power*Sin(trajectory)
        end
    end
end
